from ec import main
from functools import cache
from itertools import pairwise
import click

def p1(notes):
    names, rules = parse(notes)
    return next(n for n in names if check(n, rules))

def p2(notes):
    names, rules = parse(notes)
    return sum(i+1 for i, n in enumerate(names) if check(n, rules))

@click.option('--min-size', type=int, default='7')
@click.option('--max-size', type=int, default='11')
def p3(notes, min_size, max_size):
    prefixes, rules = parse(notes)

    @cache
    def suffixes(c, max_size):
        if max_size < 0:
            return 0
        count = 1 # the empty string
        if max_size > 0:
            for nc in rules[c]:
                count += suffixes(nc, max_size - 1)
        return count

    # remove invalid prefixes
    prefixes = [p for p in prefixes if check(p, rules)]

    # remove longer prefixes that would get generated by a shorter prefix and create duplicates
    # could sort but there's not that many prefixes anyway
    prefixes = [p for p in prefixes if not any(p.startswith(q) for q in prefixes if p != q)]

    return sum(suffixes(p[-1], max_size - len(p)) - suffixes(p[-1], min_size - 1 - len(p)) for p in prefixes)

def check(name, rules):
    for i, c in enumerate(name):
        if i + 1 < len(name) and name[i + 1] not in rules[c]:
            return False
    return True

def parse(notes):
    chunks = notes.split("\n\n")
    names = chunks[0].split(',')

    rules = {}
    for line in chunks[1].splitlines():
        pair = line.split('>')
        rules[pair[0].strip()] = set(pair[1].strip().split(','))
    
    return names, rules

if __name__ == '__main__':
    main()
